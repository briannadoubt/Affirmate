//
//  AuthenticationRouteCollection.swift
//  AffirmateServer
//
//  Created by Bri on 7/1/22.
//

import Fluent
import Vapor

struct AuthenticationRouteCollection: RouteCollection {
    func boot(routes: RoutesBuilder) throws {
        let auth = routes.grouped("auth")
        // MARK: - POST: /auth/new
        // "/new" is an open endpoint with no security validation. In the future, work in some middleware to handle denying requests based on the rate of requests, end-user's IP address, variability in account information, and other suspicious activity.
        auth.post("new") { request async throws -> User.GetResponse in
            print(request)
            try User.Create.validate(content: request)
            do {
                let create = try request.content.decode(User.Create.self)
                print(create)
                guard create.password == create.confirmPassword else {
                    throw Abort(.badRequest, reason: "Passwords do not match")
                }
                let passwordHash = try Bcrypt.hash(create.password)
                let user = User(
                    firstName: create.firstName,
                    lastName: create.lastName,
                    username: create.username,
                    email: create.email,
                    passwordHash: passwordHash
                )
                _ = try await user.create(on: request.db)
                let getResponse = user.getResponse
                print(getResponse)
                return getResponse
            } catch let abort as Abort {
                throw abort
            } catch {
                throw Abort(.internalServerError, reason: "\(error.localizedDescription)")
            }
        }
        // MARK: - GET: /auth
        auth.get { request in
            request.view.render(
                "auth", [
                    "title": "Auth",
                    "header": "Authenticate yourself, human!"
                ]
            )
        }
        // MARK: - GET: /auth/login
        // "/login" requires Basic Authentication data containing the username and password
        let passwordProtected = auth.grouped(User.authenticator(), User.guardMiddleware())
        passwordProtected.get("login") { request async throws -> User.LoginResponse in
            print(request)
            let user = try request.auth.require(User.self)
            let payload = try JWTToken(user: user)
            let jwtToken = try request.jwt.sign(payload)
            let sessionToken = try user.generateToken()
            try await sessionToken.create(on: request.db)
            return User.LoginResponse(
                jwt: JWTToken.Response(
                    jwtToken: jwtToken,
                    sesionToken: sessionToken.value
                ),
                user: user.getResponse
            )
        }
        
        // MARK: - POST: /auth/validate
        // "/validate" checks if there is a valid token on the JWT session.
        // If this check fails the client is expected to re-authenticate with another call to "/login"
        passwordProtected.post("validate") { request -> HTTPStatus in
            let _ = try request.auth.require(SessionToken.self)
            return .ok
        }
        
        // MARK: - GET: /auth/apple
        // "/apple" verifies the attached JWT Bearer token generated by Apple and sent by the client with Apple's servers for authentication verification.
        // NOTE: This route requires no prior authentication since it is used for sign up.
//        auth.get("apple") { request async throws -> Token.Response in
//            let appleIdentityToken = try await request.jwt.apple.verify()
//            let payload = Token(user: <#T##User#>)
//        }
    }
}
